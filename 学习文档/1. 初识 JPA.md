# 1. 初识 JPA

## 1.1 什么是 JPA

- Java Persistence API（JPA）是Java EE（现为 Jakarta EE）的一部分，它为对象关系映射（ORM）提供了标准。
- JPA 使 Java 对象（实体）与关系数据库中的表相映射，并提供了一种处理持久化数据的标准方式。

## 1.2 JPA 的优势

- 简化数据库操作
- 提供了一致性和独立于数据库的持久化机制
- 提高生产力和代码可维护性

# 2. 基本概念

## 2.1 实体类

- 一个实体类对应数据库中的一张表。实体类使用 `@Entity` 注解标识。

```java
import javax.persistence.Entity;
import javax.persistence.Id;

@Entity
public class Student {
    @Id
    private Long id;
    private String name;
    private int age;
    
    // getters and setters
}
```

## 2.2 主键

- 每个实体类必须有一个唯一标识主键，可以使用 `@Id` 注解标识。
- 可以通过 `@GeneratedValue` 注解自动生成主键值。

```java
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;

@Id
@GeneratedValue(strategy = GenerationType.IDENTITY)
private Long id;
```

## 2.3 数据库表的映射

- 通过 `@Table` 注解自定义表名及其他属性。

```java
import javax.persistence.Table;

@Entity
@Table(name = "students")
public class Student {
    // fields, getters, setters
}
```

# 3. 关系映射

在 JPA（Java Persistence API）中，关系映射是指如何在实体类和数据库表之间建立关联，以及如何定义这些关联的方式。JPA 提供了几种常见的关系映射类型，包括一对一、一对多、多对一和多对多。

## 3.1 一对一关系

- 使用 `@OneToOne` 注解。

### 3.1.1 单向一对一关系映射

在单向一对一关系中，只有一方维护关系。例如，一个学生只有一个身份证号码。

**实体类示例：**

```java
@Entity
public class Student {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String name;
    @OneToOne
    private IDCard idCard;

    // getters and setters
}

@Entity
public class IDCard {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String number;

    // getters and setters
}
```

在上面的例子中，`Student` 实体类持有一个 `IDCard` 类型的引用，并使用 `@OneToOne` 注解表示一对一关系。默认情况下，JPA 将会在 `Student` 表中创建一个外键列来关联 `IDCard` 表的主键。

### 3.1.2 双向一对一关系映射

在双向一对一关系中，两个实体类都持有对方的引用。

**实体类示例：**

```java
@Entity
public class Student {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String name;
    @OneToOne(mappedBy = "student")
    private IDCard idCard;

    // getters and setters
}

@Entity
public class IDCard {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String number;
    
    @OneToOne
    private Student student;

    // getters and setters
}
```

在 `IDCard` 类中使用 `@OneToOne` 注解和 `mappedBy` 属性来指定关系的维护方，从而避免了在 `Student` 类中再创建一个外键列。

## 3.2 一对多关系

- 使用 `@OneToMany` 和 `@ManyToOne` 注解。

一对多关系映射是指一个实体可以关联多个其他实体，而每个被关联的实体只能被一个实体所关联。

**实体类示例：**

```java
@Entity
public class Department {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String name;
    @OneToMany(mappedBy = "department")
    private List<Employee> employees;

    // getters and setters
}

@Entity
public class Employee {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String name;
    
    @ManyToOne
    private Department department;

    // getters and setters
}
```

在上面的例子中，`Department` 实体类使用 `@OneToMany` 注解表示一对多关系，而 `Employee` 实体类使用 `@ManyToOne` 注解表示多对一关系。使用 `mappedBy` 属性指定关系的维护方，避免在数据库中创建多余的外键列。

## 3.3 多对一关系映射

多对一关系映射与一对多关系映射相反，是指多个实体可以关联到同一个实体。

**实体类示例：**

```java
@Entity
public class Employee {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String name;
    
    @ManyToOne
    private Department department;

    // getters and setters
}

@Entity
public class Department {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String name;

    // getters and setters
}
```

在上面的例子中，`Employee` 实体类使用 `@ManyToOne` 注解表示多对一关系，关联到 `Department` 实体类。在数据库中，`Employee` 表中将会有一个外键列指向 `Department` 表的主键。

## 3.4 多对多关系映射

多对多关系映射是指多个实体可以相互关联。

**实体类示例：**

```java
@Entity
public class Student {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String name;
    
    @ManyToMany
    @JoinTable(
        name = "student_course",
        joinColumns = @JoinColumn(name = "student_id"),
        inverseJoinColumns = @JoinColumn(name = "course_id")
    )
    private List<Course> courses;

    // getters and setters
}

@Entity
public class Course {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String name;

    @ManyToMany(mappedBy = "courses")
    private List<Student> students;

    // getters and setters
}
```

在上面的例子中，`Student` 和 `Course` 之间使用 `@ManyToMany` 注解表示多对多关系。在 `Student` 实体类中，通过 `@JoinTable` 注解来指定关联表的信息，包括表名和关联字段。在 `Course` 实体类中，使用 `mappedBy` 属性来指定关系的维护方，避免在数据库中创建多余的外键列。

# 4. Spring Data JPA

## 4.1 引入依赖

在 `pom.xml` 中添加 Spring Data JPA 依赖。

```java
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-jpa</artifactId>
</dependency>
```

## 4.2 配置数据库连接

在 `application.properties` 中配置数据库连接信息。

```java
spring.datasource.url=jdbc:mysql://localhost:3306/mydb
spring.datasource.username=root
spring.datasource.password=root
spring.jpa.hibernate.ddl-auto=update
```

## 4.3 定义 Repository 接口

通过继承 `JpaRepository`，Spring Data JPA 自动提供 CRUD 操作。

```java
import org.springframework.data.jpa.repository.JpaRepository;

public interface StudentRepository extends JpaRepository<Student, Long> {
}
```

## 4.4 使用 Repository

在服务类中注入并使用 `StudentRepository`。

```java
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

@Service
public class StudentService {
    
    @Autowired
    private StudentRepository studentRepository;
    
    public List<Student> findAllStudents() {
        return studentRepository.findAll();
    }
    
    public Student saveStudent(Student student) {
        return studentRepository.save(student);
    }
}
```